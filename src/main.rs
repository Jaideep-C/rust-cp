use std::io::StdinLock;


const MODULO: i64 = 1_000_000_007;
const TESTCASE_AVAILABLE: bool = true;

fn solve(
    scanner: &mut Scanner<StdinLock>
) {
}


#[cfg(test)]
#[allow(dead_code)]
mod tests {
    use std::collections::{HashSet, HashMap};

    use proptest::proptest;
    use proptest::prelude::*;
    use proptest::sample::SizeRange;
    use proptest::strategy::{Strategy, BoxedStrategy};
    use proptest::collection;

    /// Generates a `Vec<T>` where `T` is generated by `element_generator` and the size of the vector is within `size_range`.
    ///
    /// # Example
    ///
    /// ```
    /// let element_generator = (0..10).prop_map(|x| x).boxed();
    /// let size_range = 5..=100;
    /// let vector_generator = vec_generator(element_generator, size_range);
    /// ```
    fn vec_generator<T: 'static + std::fmt::Debug>(element_generator: BoxedStrategy<T>, size_range: impl Into<SizeRange>) -> BoxedStrategy<Vec<T>> {
        collection::vec(element_generator, size_range).boxed()
    }

    /// Generates a `HashSet<T>` where `T` is generated by `element_generator` and the size of the set is within `size_range`.
    ///
    /// # Example
    ///
    /// ```
    /// let element_generator = (0..10).prop_map(|x| x).boxed();
    /// let size_range = 5..=100;
    /// let set_generator = hash_set_generator(element_generator, size_range);
    /// ```
    fn hash_set_generator<T: 'static + std::hash::Hash + std::cmp::Eq + std::fmt::Debug>(
        element_generator: BoxedStrategy<T>,
        size_range: impl Into<SizeRange>,
    ) -> BoxedStrategy<HashSet<T>> {
        collection::hash_set(element_generator, size_range).boxed()
    }

    /// Generates a `HashMap<K, V>` where `K` is generated by `key_generator`, `V` is generated by `value_generator`, and the size of the map is within `size_range`.
    ///
    /// # Example
    ///
    /// ```
    /// let key_generator = (0..10).prop_map(|x| x).boxed();
    /// let value_generator = (0..10).prop_map(|x| x).boxed();
    /// let size_range = 5..=100;
    /// let map_generator = hash_map_generator(key_generator, value_generator, size_range);
    /// ```
    fn hash_map_generator<K: 'static + std::hash::Hash + std::cmp::Eq + std::fmt::Debug, V: 'static + std::fmt::Debug>(key_generator: BoxedStrategy<K>, value_generator: BoxedStrategy<V>, size_range: std::ops::Range<usize>) -> BoxedStrategy<HashMap<K, V>> {
        collection::hash_map(key_generator, value_generator, size_range).boxed()
    }
    proptest! {
        #![proptest_config(ProptestConfig {
            fork: true,
            // timeout: 1000,
            cases: 100_000,
            .. ProptestConfig::default()
        })]

    }
}

fn main() {
    let mut scanner = Scanner::new(std::io::stdin().lock());
    let t: i64 = if TESTCASE_AVAILABLE { scanner.next() } else { 1 };
    for _ in 0..t {
        solve(&mut scanner);
    }
}


// from https://pastebin.com/raw/qRsQwBQe
pub struct Scanner<R> {
    reader: R,
    buf_str: Vec<u8>,
    offset: usize,
}

impl<R: std::io::BufRead> Scanner<R> {
    pub fn new(reader: R) -> Self {
        Self {
            reader,
            buf_str: vec![],
            offset: 0,
        }
    }

    pub fn next<T: std::str::FromStr>(&mut self) -> T {
        loop {
            if self.offset < self.buf_str.len() {
                let pos = self.buf_str[self.offset..]
                    .iter()
                    .position(|&c| c == b' ')
                    .unwrap_or(self.buf_str.len() - self.offset);

                let token = std::str::from_utf8(&self.buf_str[self.offset..self.offset + pos])
                    .expect("non utf8")
                    .trim();

                self.offset += pos + 1;
                return token.parse().ok().expect("Failed parse");
            }
            self.buf_str.clear();
            self.reader
                .read_until(b'\n', &mut self.buf_str)
                .expect("Failed read");
            self.offset = 0;
        }
    }
    pub fn next_collection<T, C>(&mut self, n: usize) -> C
        where
            T: std::str::FromStr,
            C: std::iter::FromIterator<T>,
    {
        (0..n).map(|_| self.next()).collect()
    }
}
